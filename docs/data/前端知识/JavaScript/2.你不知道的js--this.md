---
title: 重读《你不知道的JavaScript》（上）- this
desc: 重读《你不知道的JS》系列之this
label:
  - JavaScript
date: 2025-06-17
---

## this 是什么

`this` 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。

当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈） 、函数的调用方法、传入的参数等信息。

`this` 就是记录的其中一个属性，会在函数执行的过程中用到。

## this 全面解析

### 调用位置

调用位置是函数在代码中被调用的位置，而不是声明的位置。

找调用位置最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。

```javascript
function baz() {
  // 当前调用栈是：baz
  // 因此，当前调用位置是全局作用域
  console.log('baz');
  bar(); // <-- bar的调用位置
}
function bar() {
  // 当前调用栈是：baz -> bar
  // 因此，当前调用位置在baz中
  console.log('bar');
  foo(); // <-- foo的调用位置
}
function foo() {
  // 当前调用栈是：baz -> bar -> foo
  // 因此，当前调用位置在bar中
  console.log('foo');
}
baz(); // <-- baz的调用位置
```

### 绑定规则

#### 默认绑定

默认绑定是无法应用其他规则时的默认规则。

在非严格模式下，独立调用函数（直接使用不带任何修饰的函数引用进行调用的函数）调用时会应用 `this` 的默认绑定，因此 `this` 指向全局对象。

如果使用严格模式，那么全局对象将无法使用默认绑定，因此 `this` 会绑定到 `undefined`。

#### 隐式绑定

隐式绑定需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。

```javascript
function foo() {
  console.log(this.a);
}
var obj = {
  a: 2,
  foo: foo,
};
obj.foo(); // 2
```

上述代码的调用位置会使用 `obj` 上下文来引用函数，也可以说函数被调用时 `obj` 对象“拥有”或者“包含”它。

当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 `this` 绑定到这个上下文对象。

对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说：

```javascript
function foo() {
  console.log(this.a);
}
var obj2 = {
  a: 42,
  foo: foo,
};
var obj1 = {
  a: 2,
  obj2: obj2,
};
obj1.obj2.foo(); // 42
```

上述代码中，`obj1.obj2.foo()` 的调用位置会使用 `obj2` 作为函数的上下文，因此 `this` 绑定到 `obj2` 对象。

一个最常见的 `this` 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定,比如：

```javascript
function foo() {
  console.log(this.a);
}
var obj = {
  a: 2,
  foo: foo,
};
var bar = obj.foo; // 函数别名！
var a = 'oops, global'; // a是全局对象的属性
bar(); // "oops, global"
```

虽然 `bar` 是 `obj.foo` 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 `bar` 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。

```javascript
function foo() {
  console.log(this.a);
}
function doFoo(fn) {
  // fn其实引用的是foo
  fn(); // <-- 调用位置！
}
var obj = {
  a: 2,
  foo: foo,
};
var a = 'oops, global'; // a是全局对象的属性
doFoo(obj.foo); // "oops, global"
```

参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以也会应用默认绑定。

#### 显式绑定

可以使用函数的 `call` 和 `apply` 方法对 `this` 进行显式绑定。

> 如果给 `call` 和 `apply` 方法传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 `this` 的绑定对象，这个原始值会被转换成它的对象形式（也就是 `new String(..)`、`new Boolean(..)` 或者 `new Number(..)`，这通常被称为“装箱”。

- 硬绑定：

```javascript
function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}
// 简单的辅助绑定函数
function bind(fn, obj) {
  return function () {
    return fn.apply(obj, arguments);
  };
}
var obj = {
  a: 2,
};
var bar = bind(foo, obj);
var b = bar(3); // 2 3
console.log(b); // 5
```

由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 `Function.prototype.bind`，它的用法如下：

```javascript
function foo(something) {
  console.log(this.a, something);
  return this.a + something;
}

var obj = {
  a: 2,
};
var bar = foo.bind(obj);
var b = bar(3); // 2 3
console.log(b); // 5
```

`bind` 会返回一个硬编码的新函数，并把参数设置为 `this` 的上下文。

- API 调用的“上下文”

第三方库的许多函数，以及 `JavaScript` 语言和宿主环境中许多新的内置函数，都提供了一
个可选的参数，通常被称为“上下文” （`context`） ，其作用和 `bind` 一样，确保你的回调函数使用指定的 `this`。

```javascript
function foo(el) {
  console.log(el, this.id);
}
var obj = {
  id: 'awesome',
};
// 调用foo(..)时把this绑定到obj
[1, 2, 3].forEach(foo, obj);
// 1 awesome 2 awesome 3 awesome
```

这些函数实际上就是通过 `call` 或者 `apply` 实现了显式绑定。

#### new 绑定

使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。

1. 创建（或者说构造）一个全新的对象。
2. 这个新对象会被执行[[原型]] 连接。
3. 这个新对象会绑定到函数调用的 this。
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

```javascript
function foo(a) {
  this.a = a;
}
var bar = new foo(2);
console.log(bar.a); // 2
```

使用 `new` 来调用 `foo` 时，我们会构造一个新对象并把它绑定到 `foo` 调用中的 `this`上。`new` 是最后一种可以影响函数调用时 `this` 绑定行为的方法，我们称之为 `new` 绑定。

### 优先级

如果某个调用位置可以应用多条规则该怎么办？为了解决这个问题就必须给这些规则设定优先级。

首先，默认绑定的优先级是四条规则中最低的。

再去比较隐式绑定和显式绑定的优先级：

```javascript
function foo() {
  console.log(this.a);
}
var obj1 = {
  a: 2,
  foo: foo,
};
var obj2 = {
  a: 3,
  foo: foo,
};
obj1.foo(); // 2
obj2.foo(); // 3
obj1.foo.call(obj2); // 3
obj2.foo.call(obj1); // 2
```

可以看到，显式绑定要比优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。

再来看看 `new` 绑定和隐式绑定的优先级谁高谁低:

```javascript
function foo(something) {
  this.a = something;
}
var obj1 = {
  foo: foo,
};
var obj2 = {};
obj1.foo(2);
console.log(obj1.a); // 2
obj1.foo.call(obj2, 3);
console.log(obj2.a); // 3
var bar = new obj1.foo(4);
console.log(obj1.a); // 2
console.log(bar.a); // 4
```

可以看到 `new` 绑定比隐式绑定优先级高

最后比较 `new` 绑定和显式绑定的优先级：

```javascript
function foo(something) {
  this.a = something;
}
var obj1 = {};
var bar = foo.bind(obj1);
bar(2);
console.log(obj1.a); // 2
var baz = new bar(3);
console.log(obj1.a); // 2
console.log(baz.a); // 3
```

`bar` 被硬绑定到 `obj1` 上，但是 `new bar(3)` 并没有像我们预计的那样把 `obj1.a` 修改为 `3`。相反，`new` 修改了硬绑定（到 `obj1` 的）调用 `bar` 中的 `this`。因为使用了 `new` 绑定，我们得到了一个名字为 `baz` 的新对象，并且 `baz.a` 的值是 `3`。

因此，我们可以通过以下顺序来判断 `this` 的绑定优先级：

1. 函数是否在 `new` 中调用（`new` 绑定）？如果是的话 `this` 绑定的是新创建的对象。

   `var bar = new foo()`

2. 函数是否通过 `call`、`apply`（显式绑定）或者硬绑定调用？如果是的话，`this` 绑定的是
   指定的对象。

   `var bar = foo.call(obj2)`

3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，`this` 绑定的是那个上
   下文对象。

   `var bar = obj1.foo()`

4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 `undefined`，否则绑定到全局对象。

   `var bar = foo()`
